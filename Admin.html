<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Punzzle CMS - Content Management System</title>
  <link rel="icon" type="image/png" href="https://punzzle.com/images/favicon.png">
  
  <!-- Google tag (gtag.js) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-QLL4GXB1ZX"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-QLL4GXB1ZX');
  </script>
  
  <!-- Firebase (Compatibility Version) -->
  <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore-compat.js"></script>
  <script src="firebase-setup.js"></script>
  
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }
    
    body {
      font-family: -apple-system, BlinkMacSystemFont, system-ui, sans-serif;
      background-color: #fafafa;
      color: #1a1a1a;
      margin: 0;
      padding: 0;
      line-height: 1.6;
    }
    
    /* Login Styles */
    .login-container {
      display: flex;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
      background: linear-gradient(135deg, #326891 0%, #2c5a7a 100%);
    }
    
    .login-card {
      background: white;
      border-radius: 12px;
      padding: 40px;
      width: 100%;
      max-width: 400px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.2);
    }
    
    .login-header {
      text-align: center;
      margin-bottom: 30px;
    }
    
    .login-header h1 {
      font-size: 2rem;
      color: #326891;
      margin-bottom: 10px;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 10px;
    }
    
    .login-header p {
      color: #666;
      font-size: 0.9rem;
    }
    
    .login-form .form-group {
      margin-bottom: 20px;
    }
    
    .login-form label {
      display: block;
      font-weight: 600;
      margin-bottom: 8px;
      color: #1a1a1a;
    }
    
    .login-form input {
      width: 100%;
      padding: 12px;
      border: 1px solid #d0d0d0;
      border-radius: 6px;
      font-size: 1rem;
      transition: border-color 0.3s;
    }
    
    .login-form input:focus {
      outline: none;
      border-color: #326891;
      box-shadow: 0 0 0 2px rgba(50, 104, 145, 0.2);
    }
    
    .login-btn {
      width: 100%;
      padding: 12px;
      background-color: #326891;
      color: white;
      border: none;
      border-radius: 6px;
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
      transition: background-color 0.3s;
    }
    
    .login-btn:hover {
      background-color: #2c5a7a;
    }
    
    .login-btn:disabled {
      background-color: #ccc;
      cursor: not-allowed;
    }
    
    .login-error {
      background: #f8d7da;
      color: #721c24;
      padding: 10px;
      border-radius: 4px;
      margin-bottom: 20px;
      font-size: 0.9rem;
      text-align: center;
      display: none;
    }
    
    .login-attempts {
      text-align: center;
      color: #666;
      font-size: 0.85rem;
      margin-top: 10px;
    }
    
    .forgot-password {
      text-align: center;
      margin-top: 15px;
    }
    
    .forgot-password a {
      color: #326891;
      text-decoration: none;
      font-size: 0.9rem;
    }
    
    .forgot-password a:hover {
      text-decoration: underline;
    }
    
    /* Recovery Modal */
    .recovery-modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0,0,0,0.5);
      z-index: 2000;
      align-items: center;
      justify-content: center;
    }
    
    .recovery-modal.active {
      display: flex;
    }
    
    .recovery-card {
      background: white;
      border-radius: 12px;
      padding: 40px;
      width: 100%;
      max-width: 400px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.2);
    }
    
    .recovery-header h2 {
      color: #326891;
      margin-bottom: 20px;
      text-align: center;
    }
    
    .recovery-code-display {
      background: #f8fafc;
      border: 2px dashed #326891;
      border-radius: 8px;
      padding: 20px;
      margin: 20px 0;
      text-align: center;
    }
    
    .recovery-code-display code {
      font-size: 1.2rem;
      font-weight: 700;
      color: #326891;
      letter-spacing: 2px;
      font-family: monospace;
    }
    
    .recovery-warning {
      background: #fff3cd;
      border: 1px solid #ffeaa7;
      border-radius: 6px;
      padding: 15px;
      margin: 20px 0;
      font-size: 0.9rem;
      color: #856404;
    }
    
    .recovery-warning strong {
      display: block;
      margin-bottom: 5px;
    }
    
    /* Main App Styles (hidden by default) */
    .app-container {
      display: none;
    }
    
    .header {
      background-color: #326891;
      color: white;
      padding: 20px 0;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      position: relative;
    }
    
    .header h1 {
      text-align: center;
      font-size: 2rem;
      margin: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 10px;
    }
    
    .logout-btn {
      position: absolute;
      right: 20px;
      top: 50%;
      transform: translateY(-50%);
      background: rgba(255,255,255,0.2);
      color: white;
      border: 1px solid rgba(255,255,255,0.3);
      padding: 8px 16px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.9rem;
      transition: all 0.3s;
    }
    
    .logout-btn:hover {
      background: rgba(255,255,255,0.3);
    }
    
    .session-info {
      position: absolute;
      left: 20px;
      top: 50%;
      transform: translateY(-50%);
      font-size: 0.85rem;
      opacity: 0.8;
    }
    
    .container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px;
    }
    
    .tabs {
      display: flex;
      gap: 0;
      margin-bottom: 30px;
      background: white;
      border-radius: 8px;
      overflow: hidden;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    
    .tab {
      flex: 1;
      padding: 15px 20px;
      background: white;
      border: none;
      cursor: pointer;
      font-size: 1rem;
      font-weight: 600;
      color: #666;
      transition: all 0.3s;
      border-bottom: 3px solid transparent;
    }
    
    .tab:hover {
      background-color: #f8fafc;
      color: #326891;
    }
    
    .tab.active {
      color: #326891;
      border-bottom-color: #326891;
      background-color: #f8fafc;
    }
    
    .tab-content {
      display: none;
    }
    
    .tab-content.active {
      display: block;
    }
    
    .card {
      background: white;
      border-radius: 8px;
      padding: 30px;
      margin-bottom: 20px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    }
    
    .form-group {
      margin-bottom: 20px;
    }
    
    .form-group label {
      display: block;
      font-weight: 600;
      margin-bottom: 8px;
      color: #1a1a1a;
    }
    
    .form-group input,
    .form-group textarea,
    .form-group select {
      width: 100%;
      padding: 10px;
      border: 1px solid #d0d0d0;
      border-radius: 6px;
      font-size: 1rem;
      transition: border-color 0.3s;
      background-color: #ffffff;
    }
    
    .form-group input:focus,
    .form-group textarea:focus,
    .form-group select:focus {
      outline: none;
      border-color: #326891;
      box-shadow: 0 0 0 2px rgba(50, 104, 145, 0.2);
    }
    
    .form-group textarea {
      resize: vertical;
      min-height: 300px;
      font-family: monospace;
      font-size: 0.9rem;
    }
    
    .category-inputs {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }
    
    .category-row {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }
    
    .category-plus {
      font-weight: 600;
      color: #326891;
      font-size: 1.2rem;
      text-align: center;
      padding: 0 10px;
    }
    
    .btn {
      padding: 10px 20px;
      border: none;
      border-radius: 6px;
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s;
      text-decoration: none;
      display: inline-block;
    }
    
    .btn-primary {
      background-color: #326891;
      color: white;
    }
    
    .btn-primary:hover {
      background-color: #2c5a7a;
    }
    
    .btn-secondary {
      background-color: #ffffff;
      color: #666666;
      border: 1px solid #d0d0d0;
    }
    
    .btn-secondary:hover {
      background-color: #f8fafc;
      color: #1a1a1a;
    }
    
    .btn-danger {
      background-color: #c9372c;
      color: white;
    }
    
    .btn-danger:hover {
      background-color: #a02e24;
    }
    
    .btn-success {
      background-color: #00875a;
      color: white;
    }
    
    .btn-success:hover {
      background-color: #00714a;
    }
    
    .btn-group {
      display: flex;
      gap: 10px;
      margin-top: 20px;
      flex-wrap: wrap;
    }
    
    .date-selector {
      display: flex;
      gap: 10px;
      align-items: center;
      flex-wrap: wrap;
    }
    
    .quick-dates {
      display: flex;
      gap: 5px;
    }
    
    .quick-date-btn {
      padding: 5px 10px;
      font-size: 0.85rem;
      background: #e9ecef;
      border: 1px solid #dee2e6;
      border-radius: 4px;
      cursor: pointer;
      transition: all 0.3s;
    }
    
    .quick-date-btn:hover {
      background: #dee2e6;
    }
    
    .help-text {
      font-size: 0.85rem;
      color: #6c757d;
      margin-top: 5px;
    }
    
    .preview-box {
      background: #f8fafc;
      border: 1px solid #e5e5e5;
      border-radius: 6px;
      padding: 20px;
      margin-top: 20px;
    }
    
    .preview-title {
      font-weight: 600;
      margin-bottom: 15px;
      color: #326891;
      font-size: 1.1rem;
    }
    
    .preview-content {
      background: white;
      border: 1px solid #e5e5e5;
      border-radius: 4px;
      padding: 15px;
      margin-bottom: 10px;
    }
    
    .preview-date {
      font-weight: 600;
      color: #326891;
      margin-bottom: 5px;
    }
    
    .preview-categories {
      font-size: 0.875rem;
      font-weight: 600;
      color: #326891;
      padding: 0.5rem;
      background-color: rgba(50, 104, 145, 0.1);
      border: 1px solid rgba(50, 104, 145, 0.2);
      border-radius: 4px;
      text-transform: uppercase;
      margin-bottom: 10px;
      text-align: center;
    }
    
    .preview-answer {
      font-size: 0.9rem;
      color: #666;
      margin-bottom: 5px;
    }
    
    .puzzle-list {
      display: grid;
      gap: 1rem;
    }
    
    .puzzle-item {
      background: #f8f9fa;
      border: 1px solid #dee2e6;
      border-radius: 6px;
      padding: 15px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      transition: all 0.2s;
    }
    
    .puzzle-item:hover {
      background: #f0f7ff;
      border-color: #326891;
    }
    
    .puzzle-info {
      flex: 1;
    }
    
    .puzzle-date {
      font-weight: 600;
      color: #326891;
      margin-bottom: 5px;
    }
    
    .puzzle-categories {
      font-size: 0.9rem;
      color: #1a1a1a;
      margin-bottom: 3px;
    }
    
    .puzzle-answer {
      font-size: 0.85rem;
      color: #666;
      font-style: italic;
    }
    
    .puzzle-actions {
      display: flex;
      gap: 10px;
    }
    
    .stats-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 20px;
      margin-bottom: 30px;
    }
    
    .stat-card {
      background: white;
      border-radius: 8px;
      padding: 20px;
      text-align: center;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      border: 1px solid #e5e5e5;
    }
    
    .stat-number {
      font-size: 2rem;
      font-weight: 700;
      color: #326891;
      margin-bottom: 5px;
    }
    
    .stat-label {
      font-size: 0.9rem;
      color: #666;
    }
    
    .analytics-table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 20px;
    }
    
    .analytics-table th,
    .analytics-table td {
      padding: 12px;
      text-align: left;
      border-bottom: 1px solid #dee2e6;
    }
    
    .analytics-table th {
      background-color: #f8f9fa;
      font-weight: 600;
      color: #1a1a1a;
    }
    
    .analytics-table tr:hover {
      background-color: #f8f9fa;
    }
    
    .message {
      padding: 12px 20px;
      border-radius: 6px;
      margin-bottom: 20px;
      font-weight: 500;
      animation: slideIn 0.3s ease-out;
    }
    
    @keyframes slideIn {
      from {
        transform: translateY(-20px);
        opacity: 0;
      }
      to {
        transform: translateY(0);
        opacity: 1;
      }
    }
    
    .message.success {
      background: #d4edda;
      color: #155724;
      border: 1px solid #c3e6cb;
    }
    
    .message.error {
      background: #f8d7da;
      color: #721c24;
      border: 1px solid #f5c6cb;
    }
    
    .loading {
      display: inline-block;
      width: 20px;
      height: 20px;
      border: 3px solid #f3f3f3;
      border-top: 3px solid #326891;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin-left: 10px;
    }
    
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    
    .filter-controls {
      display: flex;
      gap: 10px;
      margin-bottom: 20px;
      flex-wrap: wrap;
    }
    
    .filter-controls input,
    .filter-controls select {
      padding: 8px 12px;
      border: 1px solid #d0d0d0;
      border-radius: 4px;
    }
    
    /* Bonus Puzzle Styles */
    .bonus-item {
      background: #f0f7ff;
      border: 1px solid #326891;
      border-radius: 6px;
      padding: 20px;
      margin-bottom: 15px;
    }
    
    .bonus-header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      margin-bottom: 15px;
    }
    
    .bonus-title {
      font-size: 1.1rem;
      font-weight: 600;
      color: #326891;
      margin-bottom: 5px;
    }
    
    .bonus-stats {
      display: flex;
      gap: 20px;
      font-size: 0.85rem;
      color: #666;
      margin: 10px 0;
    }
    
    .bonus-links {
      background: #f8fafc;
      border: 1px solid #e5e5e5;
      border-radius: 4px;
      padding: 15px;
      margin: 15px 0;
    }
    
    .link-row {
      display: flex;
      align-items: center;
      margin-bottom: 10px;
    }
    
    .link-row:last-child {
      margin-bottom: 0;
    }
    
    .link-label {
      font-weight: 600;
      width: 100px;
      font-size: 0.85rem;
    }
    
    .link-input {
      flex: 1;
      padding: 6px 10px;
      border: 1px solid #d0d0d0;
      border-radius: 4px;
      font-family: monospace;
      font-size: 0.85rem;
      background: white;
    }
    
    .copy-btn {
      padding: 6px 12px;
      margin-left: 10px;
      background: #326891;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.85rem;
    }
    
    .copy-btn:hover {
      background: #2c5a7a;
    }
    
    .email-preview {
      background: white;
      border: 1px solid #e5e5e5;
      border-radius: 6px;
      padding: 20px;
      margin-top: 15px;
    }
    
    .puzzle-preview {
      display: inline-block;
      margin: 20px 0;
    }
    
    .preview-row {
      display: flex;
      gap: 4px;
      margin-bottom: 4px;
      justify-content: center;
    }
    
    .preview-tile {
      width: 24px;
      height: 24px;
      background: #f8fafc;
      border: 1px solid #d0d0d0;
      border-radius: 3px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: 0.75rem;
      font-weight: 700;
    }
    
    .status-badge {
      display: inline-block;
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 0.75rem;
      font-weight: 600;
    }
    
    .status-active {
      background: #d4edda;
      color: #155724;
    }
    
    .status-expired {
      background: #f8d7da;
      color: #721c24;
    }
    
    .custom-puzzle-item {
      background: #f8f9fa;
      border: 1px solid #dee2e6;
      border-radius: 6px;
      padding: 15px;
      margin-bottom: 10px;
      position: relative;
    }
    
    .custom-puzzle-item:hover {
      background: #f0f7ff;
      border-color: #326891;
    }
    
    .custom-stats {
      display: flex;
      gap: 15px;
      font-size: 0.85rem;
      color: #666;
      margin-top: 5px;
    }
    
    .delete-custom-btn {
      position: absolute;
      top: 15px;
      right: 15px;
      background: #c9372c;
      color: white;
      border: none;
      padding: 4px 8px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.75rem;
    }
    
    .delete-custom-btn:hover {
      background: #a02e24;
    }
    
    /* Firebase Status Indicator */
    .firebase-status {
      padding: 10px;
      border-radius: 4px;
      margin-bottom: 20px;
      text-align: center;
      font-size: 0.875rem;
    }
    
    .firebase-connected {
      background: #d4edda;
      color: #155724;
      border: 1px solid #c3e6cb;
    }
    
    .firebase-error {
      background: #f8d7da;
      color: #721c24;
      border: 1px solid #f5c6cb;
    }
    
    @media (max-width: 768px) {
      .container {
        padding: 10px;
      }
      
      .card {
        padding: 20px;
      }
      
      .tabs {
        flex-direction: column;
      }
      
      .tab {
        border-bottom: none;
        border-left: 3px solid transparent;
      }
      
      .tab.active {
        border-left-color: #326891;
        border-bottom-color: transparent;
      }
      
      .btn-group {
        flex-direction: column;
      }
      
      .puzzle-item {
        flex-direction: column;
        align-items: flex-start;
      }
      
      .puzzle-actions {
        margin-top: 10px;
        width: 100%;
        justify-content: flex-start;
      }
      
      .stats-grid {
        grid-template-columns: 1fr;
      }
      
      .category-row {
        flex-direction: column;
      }
      
      .category-plus {
        display: none;
      }
      
      .logout-btn,
      .session-info {
        position: static;
        transform: none;
        margin-top: 10px;
        display: block;
        text-align: center;
      }
      
      .header {
        text-align: center;
        padding-bottom: 30px;
      }
    }
  </style>
</head>
<body>
  <!-- Login Screen -->
  <div class="login-container" id="loginContainer">
    <div class="login-card">
      <div class="login-header">
        <h1>ü¶ä Punzzle CMS</h1>
        <p>Please sign in to continue</p>
      </div>
      
      <div class="login-error" id="loginError"></div>
      
      <form class="login-form" id="loginForm">
        <div class="form-group">
          <label for="username">Username</label>
          <input type="text" id="username" name="username" required autocomplete="username">
        </div>
        
        <div class="form-group">
          <label for="password">Password</label>
          <input type="password" id="password" name="password" required autocomplete="current-password">
        </div>
        
        <button type="submit" class="login-btn" id="loginBtn">Sign In</button>
        
        <div class="login-attempts" id="loginAttempts"></div>
        
        <div class="forgot-password">
          <a href="#" onclick="showRecoveryModal(); return false;">Forgot password?</a>
        </div>
      </form>
    </div>
  </div>

  <!-- Recovery Modal -->
  <div class="recovery-modal" id="recoveryModal">
    <div class="recovery-card">
      <div class="recovery-header">
        <h2>Password Recovery</h2>
      </div>
      
      <div id="recoveryStep1" style="display: block;">
        <p>Enter your recovery code to reset your password:</p>
        
        <form id="recoveryForm">
          <div class="form-group">
            <label for="recoveryCodeInput">Recovery Code</label>
            <input type="text" id="recoveryCodeInput" placeholder="XXXX-XXXX-XXXX-XXXX" 
                   pattern="[A-Z0-9]{4}-[A-Z0-9]{4}-[A-Z0-9]{4}-[A-Z0-9]{4}" 
                   style="text-transform: uppercase; letter-spacing: 1px; font-family: monospace;"
                   maxlength="19" autocomplete="off">
          </div>
          
          <button type="submit" class="login-btn">Verify Code</button>
        </form>
        
        <div style="text-align: center; margin-top: 20px;">
          <a href="#" onclick="closeRecoveryModal(); return false;" style="color: #666;">Cancel</a>
        </div>
      </div>
      
      <div id="recoveryStep2" style="display: none;">
        <p>Create a new password:</p>
        
        <form id="newPasswordForm">
          <div class="form-group">
            <label for="newPassword">New Password</label>
            <input type="password" id="newPassword" required minlength="8">
          </div>
          
          <div class="form-group">
            <label for="confirmPassword">Confirm Password</label>
            <input type="password" id="confirmPassword" required minlength="8">
          </div>
          
          <button type="submit" class="login-btn">Reset Password</button>
        </form>
      </div>
      
      <div id="recoverySuccess" style="display: none;">
        <div style="text-align: center; color: #00875a; margin-bottom: 20px;">
          <div style="font-size: 3rem;">‚úì</div>
          <h3>Password Reset Successfully!</h3>
        </div>
        
        <div class="recovery-code-display">
          <p style="margin-bottom: 10px;">Your new recovery code is:</p>
          <code id="newRecoveryCode"></code>
        </div>
        
        <div class="recovery-warning">
          <strong>Important!</strong>
          Save this recovery code in a secure location. You'll need it if you forget your password again.
        </div>
        
        <button class="login-btn" onclick="closeRecoveryModal()">Return to Login</button>
      </div>
    </div>
  </div>

  <!-- First Login Recovery Code Display -->
  <div class="recovery-modal" id="firstLoginModal">
    <div class="recovery-card">
      <div class="recovery-header">
        <h2>Welcome to Punzzle CMS!</h2>
      </div>
      
      <p>Your account has been set up successfully. Here is your recovery code:</p>
      
      <div class="recovery-code-display">
        <code id="initialRecoveryCode"></code>
      </div>
      
      <div class="recovery-warning">
        <strong>Important!</strong>
        Save this recovery code in a secure location (password manager, secure note, etc.). 
        You'll need it to reset your password if you forget it. This code will not be shown again.
      </div>
      
      <button class="login-btn" onclick="acknowledgeRecoveryCode()">I've Saved My Recovery Code</button>
    </div>
  </div>

  <!-- Main App (hidden until authenticated) -->
  <div class="app-container" id="appContainer">
    <div class="header">
      <div class="container">
        <div class="session-info" id="sessionInfo">
          Welcome, <strong id="currentUser"></strong>
        </div>
        <h1>ü¶ä Punzzle CMS</h1>
        <button class="logout-btn" onclick="logout()">Logout</button>
      </div>
    </div>

    <div class="container">
      <!-- Firebase Status -->
      <div id="firebaseStatus" class="firebase-status" style="display: none;"></div>
      
      <div class="tabs">
        <button class="tab active" onclick="showTab(event, 'single')">Single Puzzle</button>
        <button class="tab" onclick="showTab(event, 'bulk')">Bulk Upload</button>
        <button class="tab" onclick="showTab(event, 'manage')">Manage Puzzles</button>
        <button class="tab" onclick="showTab(event, 'custom')">Custom Puzzles</button>
        <button class="tab" onclick="showTab(event, 'bonus')">Bonus Puzzles</button>
        <button class="tab" onclick="showTab(event, 'analytics')">Analytics</button>
        <button class="tab" onclick="showTab(event, 'settings')">Settings</button>
      </div>

      <!-- Single Puzzle Tab -->
      <div id="single-tab" class="tab-content active">
        <div class="card">
          <h2>Add Single Puzzle</h2>
          <form id="singlePuzzleForm">
            <div class="form-group">
              <label for="date">Date</label>
              <div class="date-selector">
                <input type="date" id="date" required>
                <div class="quick-dates">
                  <button type="button" class="quick-date-btn" onclick="setQuickDate(0)">Today</button>
                  <button type="button" class="quick-date-btn" onclick="setQuickDate(1)">Tomorrow</button>
                  <button type="button" class="quick-date-btn" onclick="setQuickDate(7)">Next Week</button>
                </div>
              </div>
            </div>
            
            <div class="form-group">
              <label>Categories</label>
              <div class="category-inputs">
                <div class="category-row">
                  <input type="text" id="category1" placeholder="First category (e.g., POP STARS)" maxlength="25" required>
                </div>
                <div class="category-plus">+</div>
                <div class="category-row">
                  <input type="text" id="category2" placeholder="Second category (e.g., CONDIMENTS)" maxlength="25" required>
                </div>
              </div>
              <div class="help-text">Each category should be 25 characters or less</div>
            </div>

            <div class="form-group">
              <label for="answer">Answer</label>
              <input type="text" id="answer" placeholder="e.g., CELINE DIJON" required>
              <div class="help-text">The full answer with spaces between words (2-5 words, max 12 characters each)</div>
            </div>

            <div class="form-group">
              <label for="hint">Hint (Optional)</label>
              <input type="text" id="hint" placeholder="e.g., My heart will go on... this sandwich" maxlength="50">
              <div class="help-text">Optional hint for players. If no hint is provided, the hint button will show "Restart"</div>
            </div>

            <div class="preview-box" id="singlePreview" style="display: none;">
              <div class="preview-title">Preview</div>
              <div id="previewContent"></div>
            </div>

            <div class="btn-group">
              <button type="submit" class="btn btn-primary">Add Puzzle</button>
              <button type="button" class="btn btn-secondary" onclick="previewSingle()">Preview</button>
              <button type="button" class="btn btn-secondary" onclick="clearSingleForm()">Clear</button>
              <button type="button" class="btn btn-secondary" onclick="testFirebaseConnection()">Test Connection</button>
            </div>
          </form>
        </div>
      </div>

      <!-- Bulk Upload Tab -->
      <div id="bulk-tab" class="tab-content">
        <div class="card">
          <h2>Bulk Upload Puzzles</h2>
          
          <div class="btn-group">
            <button class="btn btn-secondary" onclick="showBulkTemplate()">Show Template</button>
            <button class="btn btn-secondary" onclick="downloadTemplate()">Download Template</button>
          </div>

          <form id="bulkPuzzleForm">
            <div class="form-group">
              <label for="bulkStartDate">Start Date</label>
              <input type="date" id="bulkStartDate" required>
              <div class="help-text">Puzzles will be assigned consecutive dates starting from this date</div>
            </div>

            <div class="form-group">
              <label for="bulkInput">Bulk Puzzle Data</label>
              <textarea id="bulkInput" placeholder="Paste your puzzles here...

Example format:
POP STARS + CONDIMENTS | CELINE DIJON | My heart will go on... this sandwich
ROMANTIC COMEDIES + SNACKS | CRAZY RICH RAISINS | A wealthy dried fruit?
ACTORS + VEGETABLES | NEIL PATRICK CARROTS | A former child star
SITCOMS + BREAKFAST FOODS | FULL HOUSE PANCAKES
SUPERHEROES + FRUITS | WONDER WOMAN GO | A tropical justice warrior

Note: Hint is optional. If omitted, the hint button will show 'Restart' for that puzzle." required></textarea>
              <div class="help-text">
                Format: CATEGORY1 + CATEGORY2 | ANSWER | HINT (optional)<br>
                One puzzle per line. Lines starting with # are ignored.
              </div>
            </div>

            <div class="preview-box" id="bulkPreview" style="display: none;">
              <div class="preview-title">Parsed Puzzles (<span id="bulkCount">0</span> puzzles)</div>
              <div id="bulkPreviewContent"></div>
            </div>

            <div class="btn-group">
              <button type="submit" class="btn btn-primary">Upload All Puzzles</button>
              <button type="button" class="btn btn-secondary" onclick="previewBulk()">Preview</button>
              <button type="button" class="btn btn-secondary" onclick="clearBulkForm()">Clear</button>
            </div>
          </form>
        </div>
      </div>

      <!-- Manage Puzzles Tab -->
      <div id="manage-tab" class="tab-content">
        <div class="card">
          <h2>Daily Puzzles</h2>
          
          <div class="filter-controls">
            <input type="date" id="filterStartDate" placeholder="Start date">
            <input type="date" id="filterEndDate" placeholder="End date">
            <button class="btn btn-secondary" onclick="filterPuzzles()">Filter</button>
            <button class="btn btn-secondary" onclick="loadAllPuzzles()">Show All</button>
            <button class="btn btn-success" onclick="exportPuzzles()">Export All</button>
          </div>

          <div class="puzzle-list" id="puzzleList">
            <!-- Puzzles will be loaded here -->
          </div>
        </div>
      </div>

      <!-- Custom Puzzles Tab -->
      <div id="custom-tab" class="tab-content">
        <div class="card">
          <h2>Custom Puzzles (User Created)</h2>
          
          <div class="filter-controls">
            <input type="text" id="customSearchInput" placeholder="Search by categories or answer...">
            <select id="customSortBy">
              <option value="created">Sort by Created Date</option>
              <option value="plays">Sort by Play Count</option>
              <option value="views">Sort by Views</option>
              <option value="shares">Sort by Shares</option>
              <option value="completed">Sort by Completion Rate</option>
              <option value="playedAnother">Sort by Play Another Rate</option>
            </select>
            <button class="btn btn-secondary" onclick="loadCustomPuzzles()">Refresh</button>
          </div>
          
          <div class="stats-grid" style="margin: 20px 0;">
            <div class="stat-card">
              <div class="stat-number" id="totalCustomPuzzles">0</div>
              <div class="stat-label">Total Custom Puzzles</div>
            </div>
            <div class="stat-card">
              <div class="stat-number" id="totalCustomViews">0</div>
              <div class="stat-label">Total Views</div>
            </div>
            <div class="stat-card">
              <div class="stat-number" id="totalCustomShares">0</div>
              <div class="stat-label">Total Shares</div>
            </div>
            <div class="stat-card">
              <div class="stat-number" id="avgCustomCompletion">0%</div>
              <div class="stat-label">Avg Completion Rate</div>
            </div>
          </div>

          <div class="puzzle-list" id="customPuzzleList">
            <!-- Custom puzzles will be loaded here -->
          </div>
        </div>
      </div>

      <!-- Bonus Puzzles Tab -->
      <div id="bonus-tab" class="tab-content">
        <div class="card">
          <h2>Create Bonus Puzzle</h2>
          <p>Create unlisted puzzles for email subscribers with unique, unguessable links.</p>
          
          <form id="bonusPuzzleForm">
            <div class="form-group">
              <label for="bonusTitle">Puzzle Title (for your reference)</label>
              <input type="text" id="bonusTitle" placeholder="e.g., Newsletter Week 12" required>
            </div>
            
            <div class="form-group">
              <label>Categories</label>
              <div class="category-inputs">
                <div class="category-row">
                  <input type="text" id="bonusCategory1" placeholder="First category" maxlength="25" required>
                </div>
                <div class="category-plus">+</div>
                <div class="category-row">
                  <input type="text" id="bonusCategory2" placeholder="Second category" maxlength="25" required>
                </div>
              </div>
            </div>

            <div class="form-group">
              <label for="bonusAnswer">Answer</label>
              <input type="text" id="bonusAnswer" placeholder="e.g., EXCLUSIVE CONTENT" required>
            </div>

            <div class="form-group">
              <label for="bonusHint">Hint (Optional)</label>
              <input type="text" id="bonusHint" placeholder="e.g., For subscribers only!" maxlength="50">
            </div>

            <div class="form-group">
              <label for="bonusExpiry">Expiry Date (Optional)</label>
              <input type="date" id="bonusExpiry">
              <div class="help-text">Puzzle will be unavailable after this date</div>
            </div>

            <div class="btn-group">
              <button type="submit" class="btn btn-primary">Create Bonus Puzzle</button>
              <button type="button" class="btn btn-secondary" onclick="previewBonusPuzzle()">Preview</button>
            </div>
          </form>
        </div>

        <div class="card">
          <h2>Active Bonus Puzzles</h2>
          
          <div class="puzzle-list" id="bonusPuzzleList">
            <!-- Bonus puzzles will be loaded here -->
          </div>
        </div>
      </div>

      <!-- Analytics Tab -->
      <div id="analytics-tab" class="tab-content">
        <div class="card">
          <h2>Analytics Dashboard</h2>
          
          <div class="stats-grid">
            <div class="stat-card">
              <div class="stat-number" id="totalPuzzles">0</div>
              <div class="stat-label">Total Puzzles</div>
            </div>
            <div class="stat-card">
              <div class="stat-number" id="totalPlays">0</div>
              <div class="stat-label">Total Plays</div>
            </div>
            <div class="stat-card">
              <div class="stat-number" id="completedPuzzles">0</div>
              <div class="stat-label">Completed</div>
            </div>
            <div class="stat-card">
              <div class="stat-number" id="incompletePuzzles">0</div>
              <div class="stat-label">Not Completed</div>
            </div>
            <div class="stat-card">
              <div class="stat-number" id="avgScore">0</div>
              <div class="stat-label">Average Score</div>
            </div>
            <div class="stat-card">
              <div class="stat-number" id="shareRate">0%</div>
              <div class="stat-label">Share Rate</div>
            </div>
          </div>

          <h3>Link Click Tracking</h3>
          <table class="analytics-table">
            <thead>
              <tr>
                <th>Link/Button</th>
                <th>Clicks Today</th>
                <th>Clicks This Week</th>
                <th>Total Clicks</th>
              </tr>
            </thead>
            <tbody id="linkTrackingTable">
              <!-- Link tracking data will be loaded here -->
            </tbody>
          </table>

          <h3 style="margin-top: 30px;">Puzzle Performance</h3>
          <table class="analytics-table">
            <thead>
              <tr>
                <th>Date</th>
                <th>Categories</th>
                <th>Plays</th>
                <th>Avg Score</th>
                <th>Completion Rate</th>
                <th>Share Rate</th>
              </tr>
            </thead>
            <tbody id="puzzlePerformanceTable">
              <!-- Puzzle performance data will be loaded here -->
            </tbody>
          </table>
        </div>
      </div>

      <!-- Settings Tab -->
      <div id="settings-tab" class="tab-content">
        <div class="card">
          <h2>Game Settings</h2>
          
          <div class="form-group">
            <label for="apiEndpoint">API Endpoint</label>
            <input type="text" id="apiEndpoint" value="/api/puzzles" placeholder="/api/puzzles">
            <div class="help-text">The endpoint for saving and loading puzzles</div>
          </div>

          <div class="form-group">
            <label for="analyticsEndpoint">Analytics Endpoint</label>
            <input type="text" id="analyticsEndpoint" value="/api/analytics" placeholder="/api/analytics">
            <div class="help-text">The endpoint for analytics data</div>
          </div>

          <div class="form-group">
            <label>
              <input type="checkbox" id="autoBackup" checked>
              Enable automatic backups
            </label>
          </div>

          <div class="form-group">
            <label>
              <input type="checkbox" id="duplicateCheck" checked>
              Check for duplicate puzzles when adding
            </label>
          </div>

          <div class="btn-group">
            <button class="btn btn-primary" onclick="saveSettings()">Save Settings</button>
            <button class="btn btn-secondary" onclick="exportAllData()">Export All Data</button>
            <button class="btn btn-secondary" onclick="importData()">Import Data</button>
            <button class="btn btn-danger" onclick="clearAllData()">Clear All Data</button>
          </div>
          
          <input type="file" id="importFile" accept=".json" style="display: none;" onchange="handleImport(event)">
        </div>

        <div class="card">
          <h2>Firebase Configuration</h2>
          <p>To fix the "error saving puzzle to database" issue, check the following:</p>
          
          <h3>1. Firebase Security Rules</h3>
          <p>Go to Firebase Console > Firestore Database > Rules and set:</p>
          <textarea readonly style="font-family: monospace; font-size: 0.85rem; background: #f8f9fa; padding: 1rem; border-radius: 4px; width: 100%; height: 120px;">
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    match /{document=**} {
      allow read, write: if true;
    }
  }
}</textarea>
          <p style="color: #c9372c; font-size: 0.85rem; margin-top: 0.5rem;">
            ‚ö†Ô∏è Warning: These rules allow anyone to read/write. For production, implement proper authentication.
          </p>
          
          <h3 style="margin-top: 1.5rem;">2. Enable Firestore</h3>
          <p>Make sure Firestore is enabled in your Firebase project:</p>
          <ol style="margin-left: 1.5rem; font-size: 0.9rem;">
            <li>Go to Firebase Console</li>
            <li>Select your project</li>
            <li>Click "Firestore Database" in the left menu</li>
            <li>Click "Create Database" if not already created</li>
            <li>Choose "Start in test mode" for now</li>
            <li>Select a location closest to your users</li>
          </ol>
          
          <h3 style="margin-top: 1.5rem;">3. Check Browser Console</h3>
          <p>Press F12 and check the Console tab for specific Firebase errors when saving a puzzle.</p>
          
          <div class="btn-group">
            <button class="btn btn-primary" onclick="testFirebaseConnection()">Test Firebase Connection</button>
            <a href="https://console.firebase.google.com" target="_blank" class="btn btn-secondary">Open Firebase Console</a>
          </div>
        </div>
        
        <div class="card">
          <h2>Security Settings</h2>
          
          <div class="form-group">
            <label for="sessionTimeout">Session Timeout (minutes)</label>
            <input type="number" id="sessionTimeout" value="30" min="5" max="1440">
            <div class="help-text">Automatically logout after this many minutes of inactivity</div>
          </div>
          
          <div class="form-group">
            <label for="maxLoginAttempts">Max Login Attempts</label>
            <input type="number" id="maxLoginAttempts" value="5" min="3" max="10">
            <div class="help-text">Lock account after this many failed login attempts</div>
          </div>
          
          <button class="btn btn-primary" onclick="updateSecuritySettings()">Update Security Settings</button>
          
          <h3 style="margin-top: 30px;">Recovery Code</h3>
          <p>Your account email: <strong>peterjwagoner@gmail.com</strong></p>
          <p>If you forget your password, you can use your recovery code to reset it.</p>
          <button class="btn btn-secondary" onclick="showNewRecoveryCode()">Generate New Recovery Code</button>
        </div>
        
        <!-- New Recovery Code Modal -->
        <div class="recovery-modal" id="newRecoveryCodeModal">
          <div class="recovery-card">
            <div class="recovery-header">
              <h2>New Recovery Code</h2>
            </div>
            
            <p>Your new recovery code has been generated:</p>
            
            <div class="recovery-code-display">
              <code id="settingsRecoveryCode"></code>
            </div>
            
            <div class="recovery-warning">
              <strong>Important!</strong>
              Save this recovery code in a secure location. Your previous recovery code is no longer valid.
            </div>
            
            <button class="login-btn" onclick="closeNewRecoveryCodeModal()">I've Saved My Recovery Code</button>
          </div>
        </div>
      </div>

      <!-- Messages Container -->
      <div id="messageContainer"></div>
    </div>
  </div>

  <script>
    // Security Configuration
    const AUTH_CONFIG = {
      username: 'peterjwagoner',
      // This is the SHA-256 hash of the password - never store plaintext passwords
      // To generate: await crypto.subtle.digest('SHA-256', new TextEncoder().encode('**molosisi99EUP'))
      passwordHash: '62c42323e50064c2d6feec747247e407fffc377bc742e277fd0a88772e58a08c',
      maxAttempts: 5,
      lockoutDuration: 15 * 60 * 1000, // 15 minutes
      sessionTimeout: 30 * 60 * 1000, // 30 minutes default
      email: 'peterjwagoner@gmail.com' // For display purposes only
    };

    // Session Management
    let sessionTimer = null;
    let lastActivity = Date.now();

    // State management
    let puzzles = [];
    let customPuzzles = [];
    let bonusPuzzles = [];
    let analytics = {
      totalPlays: 0,
      completedPuzzles: 0,
      incompletePuzzles: 0,
      avgScore: 0,
      shareRate: 0,
      linkClicks: {
        'Previous': { today: 0, week: 0, total: 0 },
        'Make Your Own': { today: 0, week: 0, total: 0 },
        'Share': { today: 0, week: 0, total: 0 },
        'Try Another': { today: 0, week: 0, total: 0 },
        'Submit Feedback': { today: 0, week: 0, total: 0 },
        'Today\'s Punzzle': { today: 0, week: 0, total: 0 },
        'Random Letter': { today: 0, week: 0, total: 0 },
        'Random Word': { today: 0, week: 0, total: 0 },
        'Hint': { today: 0, week: 0, total: 0 },
        'Restart': { today: 0, week: 0, total: 0 },
        'Play': { today: 0, week: 0, total: 0 },
        'Thoughts?': { today: 0, week: 0, total: 0 }
      },
      puzzleStats: {},
      customPuzzleStats: {}
    };

    // Initialize
    document.addEventListener('DOMContentLoaded', function() {
      checkAuthentication();
      
      // Add form listeners
      document.getElementById('loginForm').addEventListener('submit', handleLogin);
      document.getElementById('singlePuzzleForm').addEventListener('submit', handleSingleSubmit);
      document.getElementById('bulkPuzzleForm').addEventListener('submit', handleBulkSubmit);
      document.getElementById('bonusPuzzleForm').addEventListener('submit', handleBonusSubmit);
      document.getElementById('recoveryForm').addEventListener('submit', handleRecoveryCode);
      document.getElementById('newPasswordForm').addEventListener('submit', handleNewPassword);
      
      // Add real-time preview
      ['category1', 'category2', 'answer', 'hint'].forEach(id => {
        const element = document.getElementById(id);
        if (element) {
          element.addEventListener('input', previewSingle);
        }
      });
      
      // Track activity for session management
      document.addEventListener('click', updateActivity);
      document.addEventListener('keypress', updateActivity);
      
      // Format recovery code input
      const recoveryInput = document.getElementById('recoveryCodeInput');
      if (recoveryInput) {
        recoveryInput.addEventListener('input', function(e) {
          let value = e.target.value.replace(/[^A-Z0-9]/gi, '').toUpperCase();
          let formatted = '';
          
          for (let i = 0; i < value.length && i < 16; i++) {
            if (i > 0 && i % 4 === 0) {
              formatted += '-';
            }
            formatted += value[i];
          }
          
          e.target.value = formatted;
        });
      }
    });

    // Test Firebase Connection Function
    async function testFirebaseConnection() {
      const statusDiv = document.getElementById('firebaseStatus');
      statusDiv.style.display = 'block';
      statusDiv.className = 'firebase-status';
      statusDiv.innerHTML = 'Testing Firebase connection...';
      
      try {
        // Test 1: Check if Firebase is initialized
        if (!firebase || !firebase.firestore) {
          throw new Error('Firebase is not initialized properly');
        }
        
        // Test 2: Try to read from a collection
        const testRead = await db.collection('puzzles').limit(1).get();
        console.log('Read test successful');
        
        // Test 3: Try to write to a test collection
        const testDoc = db.collection('test').doc('connection-test');
        await testDoc.set({
          timestamp: firebase.firestore.FieldValue.serverTimestamp(),
          test: true
        });
        console.log('Write test successful');
        
        // Test 4: Clean up test document
        await testDoc.delete();
        
        statusDiv.className = 'firebase-status firebase-connected';
        statusDiv.innerHTML = '‚úì Firebase is connected and working properly!';
        
        setTimeout(() => {
          statusDiv.style.display = 'none';
        }, 5000);
        
      } catch (error) {
        console.error('Firebase connection error:', error);
        
        let errorMessage = 'Firebase connection failed: ';
        
        if (error.code === 'permission-denied') {
          errorMessage += 'Permission denied. Please update your Firebase security rules.';
        } else if (error.message.includes('not initialized')) {
          errorMessage += 'Firebase is not initialized. Check your firebase-setup.js file.';
        } else if (error.code === 'unavailable') {
          errorMessage += 'Firebase is unavailable. Check your internet connection.';
        } else {
          errorMessage += error.message;
        }
        
        statusDiv.className = 'firebase-status firebase-error';
        statusDiv.innerHTML = '‚úó ' + errorMessage;
        
        // Show detailed error in console
        console.error('Detailed Firebase error:', {
          code: error.code,
          message: error.message,
          stack: error.stack
        });
      }
    }

    // SHA-256 Hash Function
    async function hashPassword(password) {
      const encoder = new TextEncoder();
      const data = encoder.encode(password);
      const hashBuffer = await crypto.subtle.digest('SHA-256', data);
      const hashArray = Array.from(new Uint8Array(hashBuffer));
      const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
      return hashHex;
    }

    // Authentication Functions
    function checkAuthentication() {
      const session = getSession();
      
      if (session && session.user && session.expires > Date.now()) {
        // Valid session exists
        showApp(session.user);
      } else {
        // No valid session
        clearSession();
        showLogin();
        
        // Check if this is first time setup (no recovery code exists)
        checkFirstTimeSetup();
      }
    }

    // Recovery Code Functions
    function generateRecoveryCode() {
      const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
      let code = '';
      
      for (let i = 0; i < 4; i++) {
        if (i > 0) code += '-';
        for (let j = 0; j < 4; j++) {
          code += chars.charAt(Math.floor(Math.random() * chars.length));
        }
      }
      
      return code;
    }

    async function storeRecoveryCode(code) {
      const hash = await hashPassword(code.replace(/-/g, ''));
      localStorage.setItem('punzzle_recovery_hash', hash);
      localStorage.setItem('punzzle_recovery_setup', 'true');
    }

    async function verifyRecoveryCode(code) {
      const storedHash = localStorage.getItem('punzzle_recovery_hash');
      if (!storedHash) return false;
      
      const enteredHash = await hashPassword(code.replace(/-/g, ''));
      return enteredHash === storedHash;
    }

    function checkFirstTimeSetup() {
      const isSetup = localStorage.getItem('punzzle_recovery_setup');
      if (!isSetup) {
        // Generate and show initial recovery code
        const code = generateRecoveryCode();
        document.getElementById('initialRecoveryCode').textContent = code;
        document.getElementById('firstLoginModal').classList.add('active');
        
        // Store the recovery code
        storeRecoveryCode(code);
      }
    }

    function acknowledgeRecoveryCode() {
      document.getElementById('firstLoginModal').classList.remove('active');
    }

    function showRecoveryModal() {
      document.getElementById('recoveryModal').classList.add('active');
      document.getElementById('recoveryStep1').style.display = 'block';
      document.getElementById('recoveryStep2').style.display = 'none';
      document.getElementById('recoverySuccess').style.display = 'none';
      document.getElementById('recoveryCodeInput').value = '';
      document.getElementById('recoveryCodeInput').focus();
    }

    function closeRecoveryModal() {
      document.getElementById('recoveryModal').classList.remove('active');
      document.getElementById('recoveryForm').reset();
      document.getElementById('newPasswordForm').reset();
    }

    async function handleRecoveryCode(e) {
      e.preventDefault();
      
      const code = document.getElementById('recoveryCodeInput').value.toUpperCase();
      const isValid = await verifyRecoveryCode(code);
      
      if (isValid) {
        // Show password reset form
        document.getElementById('recoveryStep1').style.display = 'none';
        document.getElementById('recoveryStep2').style.display = 'block';
        document.getElementById('newPassword').focus();
      } else {
        showLoginError('Invalid recovery code. Please try again.');
        document.getElementById('recoveryCodeInput').select();
      }
    }

    async function handleNewPassword(e) {
      e.preventDefault();
      
      const newPassword = document.getElementById('newPassword').value;
      const confirmPassword = document.getElementById('confirmPassword').value;
      
      if (newPassword !== confirmPassword) {
        alert('Passwords do not match. Please try again.');
        return;
      }
      
      if (newPassword.length < 8) {
        alert('Password must be at least 8 characters long.');
        return;
      }
      
      try {
        // Generate new password hash
        const newHash = await hashPassword(newPassword);
        
        // Update stored password hash
        localStorage.setItem('punzzle_password_hash', newHash);
        
        // Generate new recovery code
        const newRecoveryCode = generateRecoveryCode();
        await storeRecoveryCode(newRecoveryCode);
        
        // Show success with new recovery code
        document.getElementById('recoveryStep2').style.display = 'none';
        document.getElementById('recoverySuccess').style.display = 'block';
        document.getElementById('newRecoveryCode').textContent = newRecoveryCode;
        
        // Clear any lockout
        localStorage.removeItem('punzzle_locked_until');
        resetLoginAttempts();
        
      } catch (error) {
        console.error('Error resetting password:', error);
        alert('An error occurred. Please try again.');
      }
    }

    async function handleLogin(e) {
      e.preventDefault();
      
      const username = document.getElementById('username').value.trim();
      const password = document.getElementById('password').value;
      const loginBtn = document.getElementById('loginBtn');
      const loginError = document.getElementById('loginError');
      
      // Check if account is locked
      const lockout = getLockoutStatus();
      if (lockout.isLocked) {
        const remainingTime = Math.ceil((lockout.lockedUntil - Date.now()) / 1000 / 60);
        showLoginError(`Account locked. Try again in ${remainingTime} minutes.`);
        return;
      }
      
      loginBtn.disabled = true;
      loginBtn.textContent = 'Signing in...';
      
      try {
        // Hash the entered password
        const enteredHash = await hashPassword(password);
        
        // Get the current password hash (either default or updated)
        const currentPasswordHash = localStorage.getItem('punzzle_password_hash') || AUTH_CONFIG.passwordHash;
        
        // Verify credentials
        if (username === AUTH_CONFIG.username && enteredHash === currentPasswordHash) {
          // Successful login
          createSession(username);
          resetLoginAttempts();
          showApp(username);
        } else {
          // Failed login
          incrementLoginAttempts();
          const attempts = getLoginAttempts();
          const remaining = AUTH_CONFIG.maxAttempts - attempts;
          
          if (remaining > 0) {
            showLoginError(`Invalid credentials. ${remaining} attempts remaining.`);
          } else {
            lockAccount();
            showLoginError(`Too many failed attempts. Account locked for 15 minutes.`);
          }
        }
      } catch (error) {
        console.error('Login error:', error);
        showLoginError('An error occurred. Please try again.');
      } finally {
        loginBtn.disabled = false;
        loginBtn.textContent = 'Sign In';
      }
    }

    function showLoginError(message) {
      const loginError = document.getElementById('loginError');
      
      // Check if we're in recovery modal
      if (document.getElementById('recoveryModal').classList.contains('active')) {
        alert(message);
        return;
      }
      
      loginError.textContent = message;
      loginError.style.display = 'block';
      
      setTimeout(() => {
        loginError.style.display = 'none';
      }, 5000);
    }

    // Login Attempt Management
    function getLoginAttempts() {
      const attempts = localStorage.getItem('punzzle_login_attempts');
      return attempts ? parseInt(attempts) : 0;
    }

    function incrementLoginAttempts() {
      const attempts = getLoginAttempts() + 1;
      localStorage.setItem('punzzle_login_attempts', attempts);
      updateAttemptsDisplay();
      return attempts;
    }

    function resetLoginAttempts() {
      localStorage.removeItem('punzzle_login_attempts');
      updateAttemptsDisplay();
    }

    function updateAttemptsDisplay() {
      const attempts = getLoginAttempts();
      const attemptsElement = document.getElementById('loginAttempts');
      
      if (attempts > 0 && attempts < AUTH_CONFIG.maxAttempts) {
        attemptsElement.textContent = `Login attempts: ${attempts}/${AUTH_CONFIG.maxAttempts}`;
      } else {
        attemptsElement.textContent = '';
      }
    }

    // Account Lockout
    function getLockoutStatus() {
      const lockedUntil = localStorage.getItem('punzzle_locked_until');
      
      if (lockedUntil) {
        const lockTime = parseInt(lockedUntil);
        if (lockTime > Date.now()) {
          return { isLocked: true, lockedUntil: lockTime };
        } else {
          // Lockout expired
          localStorage.removeItem('punzzle_locked_until');
          resetLoginAttempts();
        }
      }
      
      return { isLocked: false };
    }

    function lockAccount() {
      const lockedUntil = Date.now() + AUTH_CONFIG.lockoutDuration;
      localStorage.setItem('punzzle_locked_until', lockedUntil);
    }

    // Session Management
    function createSession(username) {
      const session = {
        user: username,
        created: Date.now(),
        expires: Date.now() + AUTH_CONFIG.sessionTimeout
      };
      
      sessionStorage.setItem('punzzle_session', JSON.stringify(session));
      startSessionTimer();
    }

    function getSession() {
      const sessionStr = sessionStorage.getItem('punzzle_session');
      return sessionStr ? JSON.parse(sessionStr) : null;
    }

    function clearSession() {
      sessionStorage.removeItem('punzzle_session');
      if (sessionTimer) {
        clearInterval(sessionTimer);
        sessionTimer = null;
      }
    }

    function extendSession() {
      const session = getSession();
      if (session) {
        session.expires = Date.now() + AUTH_CONFIG.sessionTimeout;
        sessionStorage.setItem('punzzle_session', JSON.stringify(session));
      }
    }

    function startSessionTimer() {
      if (sessionTimer) {
        clearInterval(sessionTimer);
      }
      
      sessionTimer = setInterval(() => {
        const session = getSession();
        
        if (!session || session.expires < Date.now()) {
          // Session expired
          logout(true);
        } else if (Date.now() - lastActivity > 5 * 60 * 1000) {
          // Check for inactivity every 5 minutes
          const remaining = Math.ceil((session.expires - Date.now()) / 1000 / 60);
          if (remaining <= 5) {
            showMessage(`Session expiring in ${remaining} minutes. Click anywhere to extend.`, 'error');
          }
        }
      }, 30000); // Check every 30 seconds
    }

    function updateActivity() {
      lastActivity = Date.now();
      extendSession();
    }

    // UI Management
    function showLogin() {
      document.getElementById('loginContainer').style.display = 'flex';
      document.getElementById('appContainer').style.display = 'none';
      document.getElementById('username').focus();
      updateAttemptsDisplay();
    }

    function showApp(username) {
      document.getElementById('loginContainer').style.display = 'none';
      document.getElementById('appContainer').style.display = 'block';
      document.getElementById('currentUser').textContent = username;
      
      // Load data
      loadData();
      setQuickDate(0); // Set today's date by default
      
      // Test Firebase connection on app load
      setTimeout(testFirebaseConnection, 1000);
    }

    function logout(expired = false) {
      clearSession();
      
      if (expired) {
        alert('Your session has expired. Please sign in again.');
      }
      
      showLogin();
    }

    // Security Settings
    function updateSecuritySettings() {
      const timeout = parseInt(document.getElementById('sessionTimeout').value);
      const maxAttempts = parseInt(document.getElementById('maxLoginAttempts').value);
      
      if (timeout >= 5 && timeout <= 1440) {
        AUTH_CONFIG.sessionTimeout = timeout * 60 * 1000;
        extendSession(); // Apply new timeout to current session
      }
      
      if (maxAttempts >= 3 && maxAttempts <= 10) {
        AUTH_CONFIG.maxAttempts = maxAttempts;
      }
      
      showMessage('Security settings updated successfully', 'success');
    }

    function showNewRecoveryCode() {
      if (confirm('Generate a new recovery code? Your current recovery code will no longer work.')) {
        const newCode = generateRecoveryCode();
        storeRecoveryCode(newCode);
        
        document.getElementById('settingsRecoveryCode').textContent = newCode;
        document.getElementById('newRecoveryCodeModal').classList.add('active');
      }
    }

    function closeNewRecoveryCodeModal() {
      document.getElementById('newRecoveryCodeModal').classList.remove('active');
    }

    // Tab management with event parameter
    function showTab(event, tabName) {
      // Hide all tabs
      document.querySelectorAll('.tab-content').forEach(tab => {
        tab.classList.remove('active');
      });
      document.querySelectorAll('.tab').forEach(tab => {
        tab.classList.remove('active');
      });
      
      // Show selected tab
      document.getElementById(tabName + '-tab').classList.add('active');
      event.target.classList.add('active');
      
      // Load data for specific tabs
      if (tabName === 'manage') {
        loadAllPuzzles();
      } else if (tabName === 'custom') {
        loadCustomPuzzles();
      } else if (tabName === 'analytics') {
        loadAnalytics();
      } else if (tabName === 'bonus') {
        loadBonusPuzzles();
      }
    }

    // Quick date helpers
    function setQuickDate(daysFromNow) {
      const date = new Date();
      date.setDate(date.getDate() + daysFromNow);
      document.getElementById('date').value = date.toISOString().split('T')[0];
      document.getElementById('bulkStartDate').value = date.toISOString().split('T')[0];
    }

    // Single puzzle functions
    async function handleSingleSubmit(e) {
      e.preventDefault();
      
      const category1 = document.getElementById('category1').value.trim().toUpperCase();
      const category2 = document.getElementById('category2').value.trim().toUpperCase();
      
      const puzzle = {
        date: document.getElementById('date').value,
        categories: category1 + ' + ' + category2,
        answer: document.getElementById('answer').value.trim().toUpperCase(),
        hint: document.getElementById('hint').value.trim() || null,
        words: document.getElementById('answer').value.trim().toUpperCase().split(' ').filter(w => w),
        created: new Date().toISOString()
      };
      
      // Validate
      if (!validatePuzzle(puzzle)) return;
      
      // Check for duplicates
      if (document.getElementById('duplicateCheck')?.checked) {
        const duplicate = puzzles.find(p => p.date === puzzle.date);
        if (duplicate && !confirm(`A puzzle already exists for ${puzzle.date}. Replace it?`)) {
          return;
        }
      }
      
      // Save puzzle
      await savePuzzle(puzzle);
    }

    function previewSingle() {
      const category1 = document.getElementById('category1').value || 'CATEGORY 1';
      const category2 = document.getElementById('category2').value || 'CATEGORY 2';
      const answer = document.getElementById('answer').value || 'ANSWER';
      const hint = document.getElementById('hint').value;
      const words = answer.trim().toUpperCase().split(' ').filter(w => w);
      
      const preview = document.getElementById('singlePreview');
      const content = document.getElementById('previewContent');
      
      content.innerHTML = `
        <div class="preview-content">
          <div class="preview-categories">${category1.toUpperCase()} + ${category2.toUpperCase()}</div>
          <div class="preview-answer">Answer: ${answer.toUpperCase()}</div>
          <div class="preview-answer">Words: ${words.join(', ')}</div>
          ${hint ? `<div class="preview-answer">Hint: ${hint}</div>` : '<div class="preview-answer">No hint (button will show "Restart")</div>'}
        </div>
      `;
      
      preview.style.display = 'block';
    }

    function clearSingleForm() {
      document.getElementById('singlePuzzleForm').reset();
      document.getElementById('singlePreview').style.display = 'none';
      setQuickDate(0);
    }

    // Bulk upload functions
    function showBulkTemplate() {
      const template = `# Bulk Puzzle Template
# Format: CATEGORY1 + CATEGORY2 | ANSWER | HINT (optional)
# One puzzle per line
# Lines starting with # are ignored
# If no hint is provided, the hint button will show "Restart"

POP STARS + CONDIMENTS | CELINE DIJON | My heart will go on... this sandwich
ROMANTIC COMEDIES + SNACKS | CRAZY RICH RAISINS | A wealthy dried fruit?
ACTORS + VEGETABLES | NEIL PATRICK CARROTS | A former child star
SITCOMS + BREAKFAST FOODS | FULL HOUSE PANCAKES
SUPERHEROES + FRUITS | WONDER WOMAN GO | A tropical justice warrior
MOVIE FRANCHISES + DESSERTS | STAR WARS SUNDAE
MUSICIANS + PASTA | JUSTIN TIMBER LAKE LINGUINE | Bringing spaghetti back
TV SHOWS + BEVERAGES | GAME OF SCONES TEA`;

      document.getElementById('bulkInput').value = template;
      previewBulk();
    }

    function downloadTemplate() {
      const template = `# Bulk Puzzle Template for Punzzle
# Format: CATEGORY1 + CATEGORY2 | ANSWER | HINT (optional)
# One puzzle per line
# Lines starting with # are ignored
# If no hint is provided, the hint button will show "Restart"

POP STARS + CONDIMENTS | CELINE DIJON | My heart will go on... this sandwich
ROMANTIC COMEDIES + SNACKS | CRAZY RICH RAISINS | A wealthy dried fruit?
ACTORS + VEGETABLES | NEIL PATRICK CARROTS | A former child star
SITCOMS + BREAKFAST FOODS | FULL HOUSE PANCAKES
SUPERHEROES + FRUITS | WONDER WOMAN GO | A tropical justice warrior`;

      const blob = new Blob([template], { type: 'text/plain' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'punzzle-bulk-template.txt';
      a.click();
      URL.revokeObjectURL(url);
    }

    async function handleBulkSubmit(e) {
      e.preventDefault();
      
      const startDate = new Date(document.getElementById('bulkStartDate').value);
      const bulkData = document.getElementById('bulkInput').value;
      
      const newPuzzles = parseBulkData(bulkData, startDate);
      
      if (newPuzzles.length === 0) {
        showMessage('No valid puzzles found in bulk data', 'error');
        return;
      }
      
      // Save all puzzles
      let savedCount = 0;
      let skippedCount = 0;
      
      for (const puzzle of newPuzzles) {
        if (validatePuzzle(puzzle, false)) {
          // Check for duplicates
          if (document.getElementById('duplicateCheck')?.checked) {
            const duplicate = puzzles.find(p => p.date === puzzle.date);
            if (duplicate) {
              skippedCount++;
              continue;
            }
          }
          await savePuzzle(puzzle, false);
          savedCount++;
        }
      }
      
      let message = `Successfully uploaded ${savedCount} puzzles!`;
      if (skippedCount > 0) {
        message += ` (${skippedCount} skipped due to duplicate dates)`;
      }
      
      showMessage(message, 'success');
      clearBulkForm();
    }

    function parseBulkData(data, startDate) {
      const lines = data.split('\n').filter(line => line.trim() && !line.startsWith('#'));
      const parsedPuzzles = [];
      
      lines.forEach((line, index) => {
        const parts = line.split('|').map(p => p.trim());
        if (parts.length >= 2) {
          const date = new Date(startDate);
          date.setDate(date.getDate() + index);
          
          parsedPuzzles.push({
            date: date.toISOString().split('T')[0],
            categories: parts[0].toUpperCase(),
            answer: parts[1].toUpperCase(),
            hint: parts[2] || null,
            words: parts[1].toUpperCase().split(' ').filter(w => w),
            created: new Date().toISOString()
          });
        }
      });
      
      return parsedPuzzles;
    }

    function previewBulk() {
      const startDate = new Date(document.getElementById('bulkStartDate').value || new Date());
      const bulkData = document.getElementById('bulkInput').value;
      
      const parsedPuzzles = parseBulkData(bulkData, startDate);
      
      const preview = document.getElementById('bulkPreview');
      const content = document.getElementById('bulkPreviewContent');
      document.getElementById('bulkCount').textContent = parsedPuzzles.length;
      
      if (parsedPuzzles.length === 0) {
        content.innerHTML = '<p>No valid puzzles found. Check your format.</p>';
      } else {
        content.innerHTML = parsedPuzzles.map(p => `
          <div class="preview-content">
            <div class="preview-date">${p.date}</div>
            <div class="preview-categories">${p.categories}</div>
            <div class="preview-answer">Answer: ${p.answer}</div>
            ${p.hint ? `<div class="help-text">Hint: ${p.hint}</div>` : '<div class="help-text">No hint (button will show "Restart")</div>'}
          </div>
        `).join('');
      }
      
      preview.style.display = 'block';
    }

    function clearBulkForm() {
      document.getElementById('bulkPuzzleForm').reset();
      document.getElementById('bulkPreview').style.display = 'none';
      setQuickDate(0);
    }

    // Puzzle management functions
    function loadAllPuzzles() {
      displayPuzzles(puzzles);
    }

    function filterPuzzles() {
      const startDate = document.getElementById('filterStartDate').value;
      const endDate = document.getElementById('filterEndDate').value;
      
      let filtered = puzzles;
      
      if (startDate) {
        filtered = filtered.filter(p => p.date >= startDate);
      }
      
      if (endDate) {
        filtered = filtered.filter(p => p.date <= endDate);
      }
      
      displayPuzzles(filtered);
    }

    function displayPuzzles(puzzleList) {
      const container = document.getElementById('puzzleList');
      
      if (puzzleList.length === 0) {
        container.innerHTML = '<p style="text-align: center; color: #666;">No puzzles found.</p>';
        return;
      }
      
      // Sort by date descending
      puzzleList.sort((a, b) => b.date.localeCompare(a.date));
      
      container.innerHTML = puzzleList.map(p => `
        <div class="puzzle-item">
          <div class="puzzle-info">
            <div class="puzzle-date">${p.date}</div>
            <div class="puzzle-categories">${p.categories}</div>
            <div class="puzzle-answer">Answer: ${p.answer}</div>
            ${p.hint ? `<div class="help-text">Hint: ${p.hint}</div>` : '<div class="help-text">No hint</div>'}
          </div>
          <div class="puzzle-actions">
            <button class="btn btn-secondary" onclick="editPuzzle('${p.date}')">Edit</button>
            <button class="btn btn-danger" onclick="deletePuzzle('${p.date}')">Delete</button>
          </div>
        </div>
      `).join('');
    }

    function editPuzzle(date) {
      const puzzle = puzzles.find(p => p.date === date);
      if (!puzzle) return;
      
      // Switch to single puzzle tab
      const tabButton = document.querySelector('.tab');
      showTab({ target: tabButton }, 'single');
      
      // Parse categories
      const categories = puzzle.categories.split(' + ');
      
      // Fill form
      document.getElementById('date').value = puzzle.date;
      document.getElementById('category1').value = categories[0] || '';
      document.getElementById('category2').value = categories[1] || '';
      document.getElementById('answer').value = puzzle.answer;
      document.getElementById('hint').value = puzzle.hint || '';
      
      // Preview
      previewSingle();
      
      // Scroll to top
      window.scrollTo(0, 0);
    }

    // Update loadData function with better error handling
    async function loadData() {
      showMessage('Loading data...', 'success');
      
      try {
        // First, test if Firebase is working
        await testFirebaseConnection();
        
        // Load puzzles from Firebase
        showMessage('Loading puzzles from database...', 'success');
        const firebasePuzzles = await PuzzleDB.getAllPuzzles();
        
        if (firebasePuzzles && firebasePuzzles.length > 0) {
          puzzles = firebasePuzzles;
          localStorage.setItem('punzzlePuzzles', JSON.stringify(puzzles));
          showMessage(`Loaded ${firebasePuzzles.length} puzzles from database`, 'success');
        } else {
          // Fallback to localStorage if no Firebase data
          const storedPuzzles = localStorage.getItem('punzzlePuzzles');
          if (storedPuzzles) {
            puzzles = JSON.parse(storedPuzzles);
            showMessage('No puzzles in database, using local data', 'error');
          } else {
            showMessage('No puzzles found. Add your first puzzle!', 'success');
          }
        }
        
        // Load custom puzzles from Firebase
        try {
          const customSnapshot = await db.collection('customPuzzles').get();
          customPuzzles = [];
          customSnapshot.forEach(doc => {
            customPuzzles.push({ id: doc.id, ...doc.data() });
          });
          localStorage.setItem('punzzleCustomPuzzles', JSON.stringify(customPuzzles));
          console.log(`Loaded ${customPuzzles.length} custom puzzles from Firebase`);
        } catch (error) {
          console.error('Error loading custom puzzles:', error);
          const storedCustom = localStorage.getItem('punzzleCustomPuzzles');
          if (storedCustom) {
            customPuzzles = JSON.parse(storedCustom);
          }
        }
        
        // Load analytics from Firebase
        await loadFirebaseAnalytics();
        
        // Load other data from localStorage (bonus puzzles)
        const storedBonus = localStorage.getItem('punzzleBonusPuzzles');
        if (storedBonus) {
          bonusPuzzles = JSON.parse(storedBonus);
        }
        
      } catch (error) {
        console.error('Error loading data:', error);
        showMessage('Error loading from database, using offline data', 'error');
        
        // Load everything from localStorage as fallback
        const storedPuzzles = localStorage.getItem('punzzlePuzzles');
        if (storedPuzzles) {
          puzzles = JSON.parse(storedPuzzles);
        }
        
        const storedAnalytics = localStorage.getItem('punzzleAnalytics');
        if (storedAnalytics) {
          analytics = JSON.parse(storedAnalytics);
        }
        
        const storedCustom = localStorage.getItem('punzzleCustomPuzzles');
        if (storedCustom) {
          customPuzzles = JSON.parse(storedCustom);
        }
        
        const storedBonus = localStorage.getItem('punzzleBonusPuzzles');
        if (storedBonus) {
          bonusPuzzles = JSON.parse(storedBonus);
        }
      }
    }

    // New function to load analytics from Firebase
    async function loadFirebaseAnalytics() {
      try {
        // Reset analytics
        analytics = {
          totalPlays: 0,
          completedPuzzles: 0,
          incompletePuzzles: 0,
          avgScore: 0,
          shareRate: 0,
          linkClicks: {},
          puzzleStats: {},
          customPuzzleStats: {}
        };
        
        // Get game stats
        const statsSnapshot = await db.collection('gameStats')
          .orderBy('timestamp', 'desc')
          .limit(5000)
          .get();
        
        const gameStats = [];
        statsSnapshot.forEach(doc => {
          gameStats.push({ id: doc.id, ...doc.data() });
        });
        
        // Get link clicks
        const linksSnapshot = await db.collection('linkClicks')
          .orderBy('timestamp', 'desc')
          .limit(5000)
          .get();
        
        const linkClicks = [];
        linksSnapshot.forEach(doc => {
          linkClicks.push(doc.data());
        });
        
        // Process link clicks
        processLinkClicks(linkClicks);
        
        // Process game stats
        processGameStats(gameStats);
        
        // Get custom puzzle stats
        const customStats = await AnalyticsDB.getCustomPuzzleStats();
        analytics.customPuzzleStats = customStats;
        
        // Save to localStorage
        localStorage.setItem('punzzleAnalytics', JSON.stringify(analytics));
        
      } catch (error) {
        console.error('Error loading Firebase analytics:', error);
      }
    }

    // Process link clicks
    function processLinkClicks(clicks) {
      // Initialize all link types
      const linkTypes = [
        'Previous', 'Make Your Own', 'Share', 'Try Another', 
        'Submit Feedback', 'Today\'s Punzzle', 'Random Letter', 
        'Random Word', 'Hint', 'Restart', 'Play', 'Thoughts?'
      ];
      
      linkTypes.forEach(link => {
        analytics.linkClicks[link] = { today: 0, week: 0, total: 0 };
      });
      
      const today = new Date();
      today.setHours(0, 0, 0, 0);
      
      const weekAgo = new Date();
      weekAgo.setDate(weekAgo.getDate() - 7);
      weekAgo.setHours(0, 0, 0, 0);
      
      clicks.forEach(click => {
        const linkText = click.linkText || 'Unknown';
        
        // Normalize link text
        let normalizedLink = linkText;
        if (linkText.includes('Previous')) normalizedLink = 'Previous';
        else if (linkText.includes('Make') && linkText.includes('own')) normalizedLink = 'Make Your Own';
        else if (linkText.includes('Share')) normalizedLink = 'Share';
        else if (linkText.includes('Try') && linkText.includes('another')) normalizedLink = 'Try Another';
        else if (linkText.includes('Feedback')) normalizedLink = 'Submit Feedback';
        else if (linkText.includes('Random') && linkText.includes('Letter')) normalizedLink = 'Random Letter';
        else if (linkText.includes('Random') && linkText.includes('Word')) normalizedLink = 'Random Word';
        else if (linkText.includes('Hint')) normalizedLink = 'Hint';
        else if (linkText.includes('Restart')) normalizedLink = 'Restart';
        else if (linkText.includes('Play')) normalizedLink = 'Play';
        else if (linkText.includes('Thoughts')) normalizedLink = 'Thoughts?';
        
        if (!analytics.linkClicks[normalizedLink]) {
          analytics.linkClicks[normalizedLink] = { today: 0, week: 0, total: 0 };
        }
        
        const clickDate = click.timestamp?.toDate ? click.timestamp.toDate() : new Date(click.timestamp);
        
        analytics.linkClicks[normalizedLink].total++;
        
        if (clickDate >= today) {
          analytics.linkClicks[normalizedLink].today++;
        }
        
        if (clickDate >= weekAgo) {
          analytics.linkClicks[normalizedLink].week++;
        }
      });
    }

    // Add function to process game stats from Firebase
    function processGameStats(gameStats) {
      // Reset counters
      analytics.totalPlays = gameStats.length;
      analytics.completedPuzzles = 0;
      analytics.incompletePuzzles = 0;
      let totalScore = 0;
      let completedCount = 0;
      let shareCount = 0;
      
      // Process each game stat
      gameStats.forEach(stat => {
        // Count as completed if completed OR completedWithHints is true OR they have a score
        const wasCompleted = stat.completed || stat.completedWithHints || (stat.score !== undefined && stat.score !== null);
        
        if (wasCompleted) {
          analytics.completedPuzzles++;
          if (stat.score !== undefined && stat.score !== null) {
            totalScore += stat.score;
            completedCount++;
          }
        } else {
          analytics.incompletePuzzles++;
        }
        
        if (stat.shared) {
          shareCount++;
        }
        
        // Update puzzle-specific stats
        const puzzleDate = stat.date;
        if (puzzleDate && !stat.puzzleId?.startsWith('custom-') && !stat.puzzleType?.includes('custom')) {
          if (!analytics.puzzleStats[puzzleDate]) {
            analytics.puzzleStats[puzzleDate] = {
              plays: 0,
              completed: 0,
              totalScore: 0,
              hints: 0,
              shares: 0
            };
          }
          
          analytics.puzzleStats[puzzleDate].plays++;
          if (wasCompleted) {
            analytics.puzzleStats[puzzleDate].completed++;
            if (stat.score !== undefined && stat.score !== null) {
              analytics.puzzleStats[puzzleDate].totalScore += stat.score;
            }
          }
          analytics.puzzleStats[puzzleDate].hints += stat.hints || 0;
          if (stat.shared) {
            analytics.puzzleStats[puzzleDate].shares++;
          }
        }
        
        // Update custom puzzle stats
        if (stat.puzzleType === 'custom' && stat.puzzleId) {
          const customId = stat.puzzleId.replace('custom-', '');
          if (!analytics.customPuzzleStats[customId]) {
            analytics.customPuzzleStats[customId] = {
              views: 0,
              plays: 0,
              completed: 0,
              totalScore: 0,
              shares: 0,
              playedAnother: 0
            };
          }
          
          analytics.customPuzzleStats[customId].views++;
          analytics.customPuzzleStats[customId].plays++;
          if (wasCompleted) {
            analytics.customPuzzleStats[customId].completed++;
            if (stat.score !== undefined && stat.score !== null) {
              analytics.customPuzzleStats[customId].totalScore += stat.score;
            }
          }
          if (stat.shared) {
            analytics.customPuzzleStats[customId].shares++;
          }
          if (stat.playedAnother) {
            analytics.customPuzzleStats[customId].playedAnother++;
          }
        }
      });
      
      // Calculate averages
      analytics.avgScore = completedCount > 0 ? (totalScore / completedCount).toFixed(1) : 0;
      analytics.shareRate = analytics.totalPlays > 0 ? (shareCount / analytics.totalPlays) : 0;
      
      // Save updated analytics
      localStorage.setItem('punzzleAnalytics', JSON.stringify(analytics));
    }

    // Update deletePuzzle function with better error handling
    async function deletePuzzle(date) {
      if (!confirm(`Are you sure you want to delete the puzzle for ${date}?`)) return;
      
      try {
        showMessage('Deleting puzzle...', 'success');
        
        // Delete from Firebase
        const deleted = await PuzzleDB.deletePuzzle(date);
        
        if (deleted) {
          // Also remove from local storage
          puzzles = puzzles.filter(p => p.date !== date);
          localStorage.setItem('punzzlePuzzles', JSON.stringify(puzzles));
          
          loadAllPuzzles();
          showMessage('Puzzle deleted successfully', 'success');
        } else {
          showMessage('Error deleting puzzle from database', 'error');
        }
      } catch (error) {
        console.error('Error deleting puzzle:', error);
        showMessage('Error deleting puzzle: ' + error.message, 'error');
      }
    }

    // Validation
    function validatePuzzle(puzzle, showErrors = true) {
      // Check categories format
      if (!puzzle.categories.includes('+')) {
        if (showErrors) showMessage('Categories must be in format: CATEGORY1 + CATEGORY2', 'error');
        return false;
      }
      
      // Check category length
      const cats = puzzle.categories.split(' + ');
      if (cats.some(c => c.length > 25)) {
        if (showErrors) showMessage('Each category must be 25 characters or less', 'error');
        return false;
      }
      
      // Check words
      if (puzzle.words.length < 2 || puzzle.words.length > 5) {
        if (showErrors) showMessage('Answer must contain 2-5 words', 'error');
        return false;
      }
      
      // Check word length
      if (puzzle.words.some(w => w.length > 12)) {
        if (showErrors) showMessage('Each word must be 12 characters or less', 'error');
        return false;
      }
      
      // Check that words only contain letters
      if (puzzle.words.some(w => !/^[A-Z]+$/.test(w))) {
        if (showErrors) showMessage('Words can only contain letters', 'error');
        return false;
      }
      
      return true;
    }

    // Update savePuzzle function with better error handling
    async function savePuzzle(puzzle, showMsg = true) {
      try {
        if (showMsg) {
          showMessage('Saving puzzle to database...', 'success');
        }
        
        // Save to Firebase
        const saved = await PuzzleDB.savePuzzle(puzzle);
        
        if (saved) {
          // Also update local storage for offline access
          puzzles = puzzles.filter(p => p.date !== puzzle.date);
          puzzles.push(puzzle);
          localStorage.setItem('punzzlePuzzles', JSON.stringify(puzzles));
          
          if (showMsg) {
            showMessage('Puzzle saved successfully and published to game!', 'success');
            clearSingleForm();
          }
        } else {
          showMessage('Error saving puzzle to database - check console for details', 'error');
          
          // Save to local storage as fallback
          puzzles = puzzles.filter(p => p.date !== puzzle.date);
          puzzles.push(puzzle);
          localStorage.setItem('punzzlePuzzles', JSON.stringify(puzzles));
          showMessage('Saved locally but not to database. Check Firebase configuration.', 'error');
        }
      } catch (error) {
        console.error('Error in savePuzzle:', error);
        showMessage(`Error saving puzzle: ${error.message}`, 'error');
        
        // Show specific Firebase error guidance
        if (error.code === 'permission-denied') {
          showMessage('Firebase permission denied. Update your security rules.', 'error');
        } else if (error.code === 'unavailable') {
          showMessage('Firebase is unavailable. Check your internet connection.', 'error');
        }
      }
    }

    function saveData() {
      // Save to localStorage
      localStorage.setItem('punzzlePuzzles', JSON.stringify(puzzles));
      localStorage.setItem('punzzleCustomPuzzles', JSON.stringify(customPuzzles));
      localStorage.setItem('punzzleBonusPuzzles', JSON.stringify(bonusPuzzles));
      localStorage.setItem('punzzleAnalytics', JSON.stringify(analytics));
      
      // Note: Firebase saves are handled individually when puzzles are created/updated
    }

    // Custom Puzzle Management
    function loadCustomPuzzles() {
      const searchTerm = document.getElementById('customSearchInput').value.toLowerCase();
      const sortBy = document.getElementById('customSortBy').value;
      
      let filtered = customPuzzles.filter(puzzle => {
        if (!searchTerm) return true;
        return puzzle.categories.toLowerCase().includes(searchTerm) ||
               puzzle.answer.toLowerCase().includes(searchTerm);
      });
      
      // Sort puzzles
      filtered.sort((a, b) => {
        const statsA = analytics.customPuzzleStats[a.id] || {};
        const statsB = analytics.customPuzzleStats[b.id] || {};
        
        switch(sortBy) {
          case 'views':
            return (statsB.views || 0) - (statsA.views || 0);
          case 'plays':
            return (statsB.plays || 0) - (statsA.plays || 0);
          case 'shares':
            return (statsB.shares || 0) - (statsA.shares || 0);
          case 'completed':
            const compA = statsA.completed || 0;
            const compB = statsB.completed || 0;
            const playsA = statsA.plays || 1;
            const playsB = statsB.plays || 1;
            return (compB/playsB) - (compA/playsA);
          case 'playedAnother':
            return (statsB.playedAnother || 0) - (statsA.playedAnother || 0);
          default:
            return new Date(b.created) - new Date(a.created);
        }
      });
      
      // Update stats
      const totalViews = customPuzzles.reduce((sum, p) => {
        const stats = analytics.customPuzzleStats[p.id] || {};
        return sum + (stats.views || 0);
      }, 0);
      
      const totalShares = customPuzzles.reduce((sum, p) => {
        const stats = analytics.customPuzzleStats[p.id] || {};
        return sum + (stats.shares || 0);
      }, 0);
      
      const totalPlays = customPuzzles.reduce((sum, p) => {
        const stats = analytics.customPuzzleStats[p.id] || {};
        return sum + (stats.plays || 0);
      }, 0);
      
      const totalCompleted = customPuzzles.reduce((sum, p) => {
        const stats = analytics.customPuzzleStats[p.id] || {};
        return sum + (stats.completed || 0);
      }, 0);
      
      document.getElementById('totalCustomPuzzles').textContent = customPuzzles.length;
      document.getElementById('totalCustomViews').textContent = totalViews;
      document.getElementById('totalCustomShares').textContent = totalShares;
      document.getElementById('avgCustomCompletion').textContent = 
        totalPlays > 0 ? ((totalCompleted / totalPlays) * 100).toFixed(1) + '%' : '0%';
      
      displayCustomPuzzles(filtered);
    }

    // Update handleBonusSubmit function with better error handling
    async function handleBonusSubmit(e) {
      e.preventDefault();
      
      const category1 = document.getElementById('bonusCategory1').value.trim().toUpperCase();
      const category2 = document.getElementById('bonusCategory2').value.trim().toUpperCase();
      
      const puzzle = {
        title: document.getElementById('bonusTitle').value.trim(),
        categories: category1 + ' + ' + category2,
        answer: document.getElementById('bonusAnswer').value.trim().toUpperCase(),
        hint: document.getElementById('bonusHint').value.trim() || null,
        words: document.getElementById('bonusAnswer').value.trim().toUpperCase().split(' ').filter(w => w),
        expiry: document.getElementById('bonusExpiry').value || null,
        created: new Date().toISOString()
      };
      
      // Validate
      if (!validatePuzzle(puzzle)) return;
      
      try {
        showMessage('Creating bonus puzzle...', 'success');
        
        // Save to Firebase
        const bonusId = await PuzzleDB.saveBonusPuzzle(puzzle);
        
        if (bonusId) {
          puzzle.id = bonusId;
          
          // Generate URLs - use root domain without any path
          const baseUrl = window.location.origin + '/';
          puzzle.playUrl = `${baseUrl}?bonus=${bonusId}`;
          puzzle.previewUrl = `${baseUrl}?bonus=${bonusId}&preview=true`;
          
          // Update local storage
          bonusPuzzles.push(puzzle);
          localStorage.setItem('punzzleBonusPuzzles', JSON.stringify(bonusPuzzles));
          
          showMessage('Bonus puzzle created successfully!', 'success');
          document.getElementById('bonusPuzzleForm').reset();
          loadBonusPuzzles();
        } else {
          showMessage('Error creating bonus puzzle in database', 'error');
        }
      } catch (error) {
        console.error('Error creating bonus puzzle:', error);
        showMessage(`Error creating bonus puzzle: ${error.message}`, 'error');
      }
    }

    // Add function to load bonus puzzles
    function loadBonusPuzzles() {
      const container = document.getElementById('bonusPuzzleList');
      
      if (bonusPuzzles.length === 0) {
        container.innerHTML = '<p style="text-align: center; color: #666;">No bonus puzzles created yet.</p>';
        return;
      }
      
      // Sort by created date descending
      bonusPuzzles.sort((a, b) => new Date(b.created) - new Date(a.created));
      
      container.innerHTML = bonusPuzzles.map(p => {
        const isExpired = p.expiry && new Date(p.expiry) < new Date();
        const statusClass = isExpired ? 'status-expired' : 'status-active';
        const statusText = isExpired ? 'Expired' : 'Active';
        
        return `
          <div class="bonus-item">
            <div class="bonus-header">
              <div>
                <div class="bonus-title">${p.title}</div>
                <div class="puzzle-categories">${p.categories}</div>
                <div class="puzzle-answer">Answer: ${p.answer}</div>
                ${p.hint ? `<div class="help-text">Hint: ${p.hint}</div>` : '<div class="help-text">No hint</div>'}
              </div>
              <div>
                <span class="status-badge ${statusClass}">${statusText}</span>
              </div>
            </div>
            
            <div class="bonus-stats">
              <span>Created: ${new Date(p.created).toLocaleDateString()}</span>
              ${p.expiry ? `<span>Expires: ${new Date(p.expiry).toLocaleDateString()}</span>` : '<span>No expiry</span>'}
            </div>
            
            <div class="bonus-links">
              <div class="link-row">
                <span class="link-label">Play URL:</span>
                <input type="text" class="link-input" value="${p.playUrl}" readonly>
                <button class="copy-btn" onclick="copyToClipboard('${p.playUrl}')">Copy</button>
              </div>
              <div class="link-row">
                <span class="link-label">Preview URL:</span>
                <input type="text" class="link-input" value="${p.previewUrl}" readonly>
                <button class="copy-btn" onclick="copyToClipboard('${p.previewUrl}')">Copy</button>
              </div>
            </div>
          </div>
        `;
      }).join('');
    }

    // Add copy to clipboard function
    function copyToClipboard(text) {
      navigator.clipboard.writeText(text).then(() => {
        showMessage('Copied to clipboard!', 'success');
      }).catch(err => {
        console.error('Failed to copy:', err);
        showMessage('Failed to copy to clipboard', 'error');
      });
    }

    // Update the loadAnalytics function to show both local and Firebase data
    async function loadAnalytics() {
      // First show local data
      updateAnalyticsDisplay();
      
      try {
        // Then fetch fresh data from Firebase
        showMessage('Fetching latest analytics...', 'success');
        
        await loadFirebaseAnalytics();
        
        // Update display with fresh data
        updateAnalyticsDisplay();
        
      } catch (error) {
        console.error('Error fetching analytics:', error);
        showMessage('Showing cached analytics data', 'error');
      }
    }

    // Add function to update analytics display
    function updateAnalyticsDisplay() {
      // Update stats cards
      document.getElementById('totalPuzzles').textContent = puzzles.length;
      document.getElementById('totalPlays').textContent = analytics.totalPlays || 0;
      document.getElementById('completedPuzzles').textContent = analytics.completedPuzzles || 0;
      document.getElementById('incompletePuzzles').textContent = analytics.incompletePuzzles || 0;
      document.getElementById('avgScore').textContent = (analytics.avgScore || 0);
      document.getElementById('shareRate').textContent = ((analytics.shareRate || 0) * 100).toFixed(1) + '%';
      
      // Update link tracking table
      const linkTable = document.getElementById('linkTrackingTable');
      const linkData = Object.entries(analytics.linkClicks || {})
        .filter(([link, data]) => data.total > 0)
        .sort((a, b) => b[1].total - a[1].total);
      
      if (linkData.length === 0) {
        linkTable.innerHTML = '<tr><td colspan="4" style="text-align: center; color: #666;">No link click data yet. Make sure Firebase is configured correctly.</td></tr>';
      } else {
        linkTable.innerHTML = linkData.map(([link, data]) => `
          <tr>
            <td>${link}</td>
            <td>${data.today || 0}</td>
            <td>${data.week || 0}</td>
            <td>${data.total || 0}</td>
          </tr>
        `).join('');
      }
      
      // Update puzzle performance table
      const perfTable = document.getElementById('puzzlePerformanceTable');
      const puzzleStats = Object.entries(analytics.puzzleStats || {})
        .sort((a, b) => b[0].localeCompare(a[0]))
        .slice(0, 20); // Show top 20
      
      if (puzzleStats.length === 0) {
        perfTable.innerHTML = '<tr><td colspan="6" style="text-align: center; color: #666;">No analytics data yet. Play some puzzles to see stats!</td></tr>';
      } else {
        perfTable.innerHTML = puzzleStats.map(([date, stats]) => {
          const puzzle = puzzles.find(p => p.date === date);
          const completionRate = stats.plays > 0 ? (stats.completed / stats.plays) : 0;
          const avgScore = stats.completed > 0 ? (stats.totalScore / stats.completed) : 0;
          const shareRate = stats.plays > 0 ? (stats.shares / stats.plays) : 0;
          
          return `
            <tr>
              <td>${date}</td>
              <td>${puzzle?.categories || 'N/A'}</td>
              <td>${stats.plays || 0}</td>
              <td>${avgScore.toFixed(1)}</td>
              <td>${(completionRate * 100).toFixed(1)}%</td>
              <td>${(shareRate * 100).toFixed(1)}%</td>
            </tr>
          `;
        }).join('');
      }
    }
    
    function displayCustomPuzzles(puzzleList) {
      const container = document.getElementById('customPuzzleList');
      
      if (puzzleList.length === 0) {
        container.innerHTML = '<p style="text-align: center; color: #666;">No custom puzzles found.</p>';
        return;
      }
      
      container.innerHTML = puzzleList.map(p => {
        const stats = analytics.customPuzzleStats[p.id] || {};
        const views = stats.views || 0;
        const plays = stats.plays || 0;
        const completed = stats.completed || 0;
        const shares = stats.shares || 0;
        const playedAnother = stats.playedAnother || 0;
        const avgScore = stats.completed > 0 ? (stats.totalScore / stats.completed) : 0;
        const completionRate = plays > 0 ? ((completed / plays) * 100).toFixed(1) : 0;
        const playAnotherRate = plays > 0 ? ((playedAnother / plays) * 100).toFixed(1) : 0;
        
        // Generate the play URL
        const playUrl = `${window.location.origin}/?custom=${p.id}`;
        
        return `
          <div class="custom-puzzle-item">
            <button class="delete-custom-btn" onclick="deleteCustomPuzzle('${p.id}')">Delete</button>
            <div class="puzzle-info">
              <div class="puzzle-categories">${p.categories}</div>
              <div class="puzzle-answer">Answer: ${p.answer}</div>
              ${p.hint ? `<div class="help-text">Hint: ${p.hint}</div>` : '<div class="help-text">No hint</div>'}
              <div class="custom-stats">
                <span>Views: ${views}</span>
                <span>Plays: ${plays}</span>
                <span>Completed: ${completed}</span>
                <span>Shares: ${shares}</span>
                <span>Completion Rate: ${completionRate}%</span>
                <span>Played Another: ${playedAnother} (${playAnotherRate}%)</span>
                <span>Avg Score: ${avgScore.toFixed(1)}</span>
              </div>
              <div style="margin-top: 10px;">
                <div class="link-row" style="display: flex; align-items: center;">
                  <span class="link-label" style="font-weight: 600; width: 60px; font-size: 0.85rem;">URL:</span>
                  <input type="text" class="link-input" value="${playUrl}" readonly style="flex: 1; padding: 6px 10px; border: 1px solid #d0d0d0; border-radius: 4px; font-family: monospace; font-size: 0.85rem;">
                  <button class="copy-btn" onclick="copyToClipboard('${playUrl}')" style="padding: 6px 12px; margin-left: 10px;">Copy</button>
                </div>
              </div>
              <div class="help-text" style="margin-top: 5px;">Created: ${new Date(p.created).toLocaleString()}</div>
            </div>
          </div>
        `;
      }).join('');
    }
    
    async function deleteCustomPuzzle(puzzleId) {
      if (!confirm('Are you sure you want to delete this custom puzzle?')) return;
      
      try {
        // Delete from Firebase
        await db.collection('customPuzzles').doc(puzzleId).delete();
        
        // Remove from local array
        customPuzzles = customPuzzles.filter(p => p.id !== puzzleId);
        delete analytics.customPuzzleStats[puzzleId];
        
        saveData();
        loadCustomPuzzles();
        showMessage('Custom puzzle deleted successfully', 'success');
      } catch (error) {
        console.error('Error deleting custom puzzle:', error);
        showMessage('Error deleting puzzle from database', 'error');
      }
    }

    // Settings functions
    function saveSettings() {
      const settings = {
        apiEndpoint: document.getElementById('apiEndpoint').value,
        analyticsEndpoint: document.getElementById('analyticsEndpoint').value,
        autoBackup: document.getElementById('autoBackup').checked,
        duplicateCheck: document.getElementById('duplicateCheck').checked
      };
      
      localStorage.setItem('punzzleSettings', JSON.stringify(settings));
      showMessage('Settings saved successfully!', 'success');
    }

    function exportPuzzles() {
      const dataStr = JSON.stringify(puzzles, null, 2);
      const dataBlob = new Blob([dataStr], { type: 'application/json' });
      const url = URL.createObjectURL(dataBlob);
      const link = document.createElement('a');
      link.href = url;
      link.download = `punzzle-puzzles-${new Date().toISOString().split('T')[0]}.json`;
      link.click();
      URL.revokeObjectURL(url);
    }

    function exportAllData() {
      const data = {
        puzzles: puzzles,
        customPuzzles: customPuzzles,
        bonusPuzzles: bonusPuzzles,
        analytics: analytics,
        exportDate: new Date().toISOString()
      };
      
      const dataStr = JSON.stringify(data, null, 2);
      const dataBlob = new Blob([dataStr], { type: 'application/json' });
      const url = URL.createObjectURL(dataBlob);
      const link = document.createElement('a');
      link.href = url;
      link.download = `punzzle-backup-${new Date().toISOString().split('T')[0]}.json`;
      link.click();
      URL.revokeObjectURL(url);
    }

    function importData() {
      document.getElementById('importFile').click();
    }

    function handleImport(event) {
      const file = event.target.files[0];
      if (!file) return;
      
      const reader = new FileReader();
      reader.onload = function(e) {
        try {
          const data = JSON.parse(e.target.result);
          
          // Check if it's just puzzles or full backup
          if (Array.isArray(data)) {
            // Just puzzles
            if (confirm(`Import ${data.length} puzzles? This will merge with existing puzzles.`)) {
              data.forEach(puzzle => {
                if (validatePuzzle(puzzle, false)) {
                  puzzles.push(puzzle);
                }
              });
              saveData();
              showMessage(`Imported ${data.length} puzzles successfully!`, 'success');
              loadAllPuzzles();
            }
          } else if (data.puzzles) {
            // Full backup
            if (confirm('Import full backup? This will replace all existing data.')) {
              puzzles = data.puzzles || [];
              customPuzzles = data.customPuzzles || [];
              bonusPuzzles = data.bonusPuzzles || [];
              analytics = data.analytics || analytics;
              saveData();
              showMessage('Backup imported successfully!', 'success');
              loadAllPuzzles();
              loadCustomPuzzles();
              loadBonusPuzzles();
              loadAnalytics();
            }
          }
        } catch (error) {
          showMessage('Error importing file: ' + error.message, 'error');
        }
      };
      reader.readAsText(file);
      
      // Clear the input so the same file can be selected again
      event.target.value = '';
    }

    function clearAllData() {
      if (!confirm('Are you sure you want to delete ALL puzzles and analytics data?')) return;
      if (!confirm('This action cannot be undone. Are you absolutely sure?')) return;
      
      puzzles = [];
      customPuzzles = [];
      bonusPuzzles = [];
      analytics = {
        totalPlays: 0,
        completedPuzzles: 0,
        incompletePuzzles: 0,
        avgScore: 0,
        shareRate: 0,
        linkClicks: {},
        puzzleStats: {},
        customPuzzleStats: {}
      };
      
      saveData();
      showMessage('All data cleared successfully', 'success');
      loadAllPuzzles();
      loadCustomPuzzles();
      loadBonusPuzzles();
      loadAnalytics();
    }

    // Add preview bonus puzzle function
    function previewBonusPuzzle() {
      const category1 = document.getElementById('bonusCategory1').value || 'CATEGORY 1';
      const category2 = document.getElementById('bonusCategory2').value || 'CATEGORY 2';
      const answer = document.getElementById('bonusAnswer').value || 'ANSWER';
      const hint = document.getElementById('bonusHint').value;
      const words = answer.trim().toUpperCase().split(' ').filter(w => w);
      
      alert(`Preview:\n\nCategories: ${category1.toUpperCase()} + ${category2.toUpperCase()}\nAnswer: ${answer.toUpperCase()}\nWords: ${words.join(', ')}\n${hint ? `Hint: ${hint}` : 'No hint'}`);
    }

    // Message display
    function showMessage(text, type = 'success') {
      const container = document.getElementById('messageContainer');
      const message = document.createElement('div');
      message.className = `message ${type}`;
      message.textContent = text;
      
      container.appendChild(message);
      
      // Auto remove after 5 seconds
      setTimeout(() => {
        message.remove();
      }, 5000);
      
      // Remove on click
      message.addEventListener('click', () => {
        message.remove();
      });
    }
  </script>
</body>
</html>